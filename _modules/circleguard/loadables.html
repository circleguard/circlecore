<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 6.1.3 and Furo 2022.12.07 -->
        <title>circleguard.loadables - Circleguard v5.4.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Circleguard v5.4.0 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Circleguard v5.4.0 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Circlecore</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../foreword.html">Foreword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../representing-replays.html">Representing Replays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../using-circleguard.html">Using Circleguard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../replay-containers.html">Replay Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loading.html">Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../caching.html">Caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced-usage.html">Advanced Usage</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../appendix.html">Appendix</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for circleguard.loadables</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">import</span> <span class="nn">osrparse</span>
<span class="kn">from</span> <span class="nn">osrparse</span> <span class="kn">import</span> <span class="n">ReplayEventOsu</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">wtc</span>

<span class="kn">from</span> <span class="nn">circleguard.mod</span> <span class="kn">import</span> <span class="n">Mod</span>
<span class="kn">from</span> <span class="nn">circleguard.utils</span> <span class="kn">import</span> <span class="n">TRACE</span><span class="p">,</span> <span class="n">KEY_MASK</span><span class="p">,</span> <span class="n">RatelimitWeight</span>
<span class="kn">from</span> <span class="nn">circleguard.loader</span> <span class="kn">import</span> <span class="n">Loader</span>
<span class="kn">from</span> <span class="nn">circleguard.span</span> <span class="kn">import</span> <span class="n">Span</span>
<span class="kn">from</span> <span class="nn">circleguard.game_version</span> <span class="kn">import</span> <span class="n">GameVersion</span><span class="p">,</span> <span class="n">NoGameVersion</span>
<span class="kn">from</span> <span class="nn">circleguard.map_info</span> <span class="kn">import</span> <span class="n">MapInfo</span>


<div class="viewcode-block" id="Loadable"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Loadable">[docs]</a><span class="k">class</span> <span class="nc">Loadable</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents one or multiple replays, which have replay data to be loaded</span>
<span class="sd">    from some additional source - the osu! api, local cache, or some other</span>
<span class="sd">    location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replay data once loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>

<div class="viewcode-block" id="Loadable.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Loadable.load">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the information this loadable needs to become fully loaded.</span>
<span class="sd">        Details left to the subclass implementation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~circleguard.loader.Loader`</span>
<span class="sd">            The loader to load this loadable with. Although subclasses may not</span>
<span class="sd">            end up using a :class:`~circleguard.loader.Loader` to load</span>
<span class="sd">            themselves (if they don&#39;t load anything from the osu api, for</span>
<span class="sd">            instance), a loader is still passed regardless.</span>
<span class="sd">            Note: ``loader`` may be ``None``. This means that whatever is</span>
<span class="sd">            loading the loadable does not have api access and cannot provide a</span>
<span class="sd">            loader. If your loadable requires a loader to properly load itself,</span>
<span class="sd">            raise an error on a null ``loader``. If your loadable can load</span>
<span class="sd">            itself without a ``loader``, proceed as planned and ignore the null</span>
<span class="sd">            ``loader``.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache the replay data once loaded. This argument</span>
<span class="sd">            comes from a parent—either a :class:`~.ReplayContainer` or</span>
<span class="sd">            :class:`~circleguard.circleguard.Circleguard` itself. Should the</span>
<span class="sd">            loadable already have a set ``cache`` value, that should take</span>
<span class="sd">            precedence over the option passed in this method, but if the</span>
<span class="sd">            loadable has no preference then it should respect the value passed</span>
<span class="sd">            here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="LoadableContainer"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer">[docs]</a><span class="k">class</span> <span class="nc">LoadableContainer</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Loadable that holds Loadables, which may be ``ReplayContainer``\s or</span>
<span class="sd">    ``Replay``\s.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loadables: list[:class:`~.Loadable`]</span>
<span class="sd">        The loadables to hold.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the loadables once they are loaded. This will be</span>
<span class="sd">        overriden by a ``cache`` option set by a :class:`~Loadable` in</span>
<span class="sd">        ``loadables``. This only affects child loadables when they do not have</span>
<span class="sd">        a ``cache`` option set.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class is intended for situations when you have a list of replays and</span>
<span class="sd">    replay containers, but no way to separate or distinguish them. If you want</span>
<span class="sd">    to get, say, all the replays out of that list (whether they come from</span>
<span class="sd">    replay subclasses already in the list, or the replays held by a replay</span>
<span class="sd">    container in the list), this loadable container class has the logic to do</span>
<span class="sd">    that for you:</span>

<span class="sd">    &gt;&gt;&gt; lc = LoadableContainer(mixed_loadable_list)</span>
<span class="sd">    &gt;&gt;&gt; replays = lc.all_replays()</span>

<span class="sd">    It can also be useful to info load the replay containers in the list,</span>
<span class="sd">    without first filtering the list to remove any replay subclasses:</span>

<span class="sd">    &gt;&gt;&gt; cg.load_info(lc)</span>
<span class="sd">    &gt;&gt;&gt; # all loadable containers in the list are now info loaded</span>
<span class="sd">    &gt;&gt;&gt; cg.load(lc)</span>
<span class="sd">    &gt;&gt;&gt; # all loadables in the list are now loaded</span>

<span class="sd">    You are very unlikely to want to subclass this class. If you want to add a</span>
<span class="sd">    new loadable that holds replays, subclass ``ReplayContainer``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadables</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span> <span class="o">=</span> <span class="n">loadables</span>

<div class="viewcode-block" id="LoadableContainer.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All the :class:`~.Replay`\s in this loadable container.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[:class:`~Replay`]</span>
<span class="sd">            All the replays in this loadable container.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This list may be incomplete if you do not call</span>
<span class="sd">        :meth:`~circleguard.circleguard.Circleguard.load_info` on this loadable</span>
<span class="sd">        container first, as any replay containers held in this container will</span>
<span class="sd">        likely not have references to their replays yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayContainer</span><span class="p">):</span>
                <span class="n">replays</span> <span class="o">+=</span> <span class="n">loadable</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># loadable is a Replay if it&#39;s not a ReplayContainer</span>
                <span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadable</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">replays</span></div>

<div class="viewcode-block" id="LoadableContainer.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="n">cascade_cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="n">loadable</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">cascade_cache</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayContainer</span><span class="p">):</span>
                <span class="n">loadable</span><span class="o">.</span><span class="n">load_info</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">LoadableContainer</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayContainer"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer">[docs]</a><span class="k">class</span> <span class="nc">ReplayContainer</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Loadable that holds Replay subclasses, and which has an additional state</span>
<span class="sd">    between &quot;unloaded&quot; and &quot;loaded&quot; called &quot;info loaded&quot;.</span>

<span class="sd">    ReplayContainers start unloaded and become info loaded when</span>
<span class="sd">    :meth:`~circleguard.circleguard.Circleguard.load_info` is called. They</span>
<span class="sd">    become fully loaded when :meth:`~.circleguard.circleguard.Circleguard.load`</span>
<span class="sd">    is called (and if this is called when the ReplayContainer is in the unloaded</span>
<span class="sd">    state, :meth:`~Loadable.load` will load info first, then load the replays,</span>
<span class="sd">    effectively skipping the info loaded state).</span>

<span class="sd">    In the unloaded state, the container has no actual Replay objects. It may</span>
<span class="sd">    have limited knowledge about their number or type.</span>

<span class="sd">    In the info loaded state, the container has references to Replay objects,</span>
<span class="sd">    but those Replay objects are unloaded.</span>

<span class="sd">    In the loaded state, the Replay objects in the container are loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="ReplayContainer.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads all :class:`~circleguard.loadables.Loadable`\s contained by this</span>
<span class="sd">        loadable container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~circleguard.loader.Loader`</span>
<span class="sd">            The loader to load the :class:`~circleguard.loadables.Loadable`\s</span>
<span class="sd">            with.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">cascade_cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_info</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">replay</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">():</span>
            <span class="n">replay</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">cascade_cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="ReplayContainer.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer.all_replays">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all the :class:`~.Replay`\s in this loadable container.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        If you want an accurate list of :class:`~.Replay`\s in this instance,</span>
<span class="sd">        you must call :func:`~circleguard.circleguard.Circleguard.load_info` on</span>
<span class="sd">        this instance before</span>
<span class="sd">        :func:`~circleguard.loadables.ReplayContainer.all_replays`. Otherwise,</span>
<span class="sd">        this instance is not info loaded, and does not have a complete list of</span>
<span class="sd">        replays it represents.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">replays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">replays</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">replays</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">())</span></div>


<div class="viewcode-block" id="Map"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Map">[docs]</a><span class="k">class</span> <span class="nc">Map</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A map&#39;s top plays (leaderboard), as seen on the website.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    beatmap_id: int</span>
<span class="sd">        The map to represent the top plays for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of top plays to retrieve.</span>
<span class="sd">        ``span=&quot;1-3,6,2-4&quot;`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        If passed, only represent replays played with this exact mod</span>
<span class="sd">        combination. Due to limitations with the api, fuzzy matching is not</span>
<span class="sd">        implemented.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is applied before ``span``. That is, if ``span=&quot;1-2&quot;``</span>
<span class="sd">        and ``mods=Mod.HD``, the top two ``HD`` plays on the map are</span>
<span class="sd">        represented.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beatmap_id</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>

        <span class="c1"># TODO remove in core 6.0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">loader</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A Map cannot be info loaded without api access&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">score</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span>
            <span class="n">mods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">score</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">,</span> <span class="n">score</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">score</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span>
                <span class="n">cache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">score</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Map.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Map.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">beatmap_id</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Map(beatmap_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">,cache=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,span=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="si">}</span><span class="s2">,replays=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Map </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="User"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.User">[docs]</a><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A user&#39;s top plays (pp-wise, as seen on the website).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The user to represent the top plays for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of top plays to retrieve.</span>
<span class="sd">        ``span=&quot;1-3,6,2-4&quot;`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        If passed, only represent replays played with this exact mod</span>
<span class="sd">        combination. Due to limitations with the api, fuzzy matching is not</span>
<span class="sd">        implemented.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is applied before ``span``. That is, if ``span=&quot;1-2&quot;``</span>
<span class="sd">        and ``mods=Mod.HD``, the user&#39;s top two ``HD`` plays are represented.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    available_only: bool</span>
<span class="sd">        Whether to represent only replays that have replay data available.</span>
<span class="sd">        Replays are filtered on this basis after ``mods`` and ``span``</span>
<span class="sd">        are applied. True by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> \
        <span class="n">available_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="o">=</span> <span class="n">available_only</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">loader</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A User cannot be info loaded without api access&quot;</span><span class="p">)</span>
        <span class="c1"># thanks to api v1 weirdness, depending on the endpoint we use to</span>
        <span class="c1"># retrieve the Score model, the username may or may not be present (to</span>
        <span class="c1"># be explicit, `get_scores` includes the username, `get_user_best` does</span>
        <span class="c1"># not). We guarantee that this attribute is present for `ReplayMap`s</span>
        <span class="c1"># but when we pass an override `info` to it here it won&#39;t retrieve</span>
        <span class="c1"># the username, meaning it gets stuck with a `None` username. To fix</span>
        <span class="c1"># this just manually retrieve the username once here and set</span>
        <span class="c1"># `info.username` manually.</span>
        <span class="c1"># Ideally this attribute would be lazy-loaded in some form so this call</span>
        <span class="c1"># isn&#39;t hit until required, but doing so would require more complexity</span>
        <span class="c1"># than I&#39;m comfortable with for such minor savings (one api call per</span>
        <span class="c1"># unique user, since `loader.username` is @lru_cached).</span>
        <span class="n">username</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">username</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_user_best</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_available</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">info</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">username</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="User.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.User.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">User</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;User </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="MapUser"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.MapUser">[docs]</a><span class="k">class</span> <span class="nc">MapUser</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    All replays on a map by a user, not just the top replay.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    beatmap_id: int</span>
<span class="sd">        The beatmap to represent scores by `user_id` on.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The user to represent scores on `beatmap_id` for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of plays to retrieve.</span>
<span class="sd">        ``span=&quot;1-3,6,2-4&quot;`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    available_only: bool</span>
<span class="sd">        Whether to represent only replays that have replay data available.</span>
<span class="sd">        Replays are filtered on this basis after ``span`` is applied.</span>
<span class="sd">        True by default.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beatmap_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="n">Loader</span><span class="o">.</span><span class="n">MAX_MAP_SPAN</span><span class="p">,</span> \
        <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">available_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="o">=</span> <span class="n">available_only</span>

        <span class="c1"># TODO remove in core 6.0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">loader</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A MapUser cannot be info loaded without &quot;</span>
                <span class="s2">&quot;api access&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span>
            <span class="n">user_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_available</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="MapUser.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.MapUser.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">MapUser</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;MapUser for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2"> on /b/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">&quot;</span></div>

<div class="viewcode-block" id="ReplayCache"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayCache">[docs]</a><span class="k">class</span> <span class="nc">ReplayCache</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contains replays represented by a circlecore database. Primarily useful</span>
<span class="sd">    to randomly sample these replays, rather than directly access them.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: string</span>
<span class="sd">        The path to the database to load replays from.</span>
<span class="sd">    num_maps: int</span>
<span class="sd">        How many (randomly chosen) maps to load replays from.</span>
<span class="sd">    limit: int</span>
<span class="sd">        How many replays to load for each map.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    :meth:`~circleguard.circleguard.Circleguard.load_info` is an expensive</span>
<span class="sd">    operation for large databases created on circlecore version 4.3.5 or</span>
<span class="sd">    earlier, as they do not have the necessary indexes.</span>
<span class="sd">    |br|</span>
<span class="sd">    For databases created in later versions, this is a nonissue and the lookup</span>
<span class="sd">    is fast.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">,</span> <span class="n">num_replays</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span> <span class="o">=</span> <span class="n">num_maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">num_replays</span> <span class="o">*</span> <span class="n">num_maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">map_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SELECT DISTINCT map_id</span>
<span class="sd">            FROM replays</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>

        <span class="c1"># flatten map_ids, because it&#39;s actually a list of lists</span>
        <span class="n">map_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">map_ids</span><span class="p">]</span>
        <span class="n">chosen_maps</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">map_ids</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span><span class="p">)</span>

        <span class="n">subclauses</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;map_id = </span><span class="si">{</span><span class="n">chosen_map</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">chosen_map</span> <span class="ow">in</span> <span class="n">chosen_maps</span><span class="p">]</span>
        <span class="n">where_clause</span> <span class="o">=</span> <span class="s2">&quot; OR &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subclauses</span><span class="p">)</span>

        <span class="c1"># TODO LIMIT clause isn&#39;t quite right here, some maps will have less</span>
        <span class="c1"># than ``num_replays`` stored</span>
        <span class="n">infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            SELECT user_id, map_id, replay_data, replay_id, mods</span>
<span class="s2">            FROM replays</span>
<span class="s2">            WHERE </span><span class="si">{</span><span class="n">where_clause</span><span class="si">}</span>
<span class="s2">            LIMIT </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="si">}</span>
<span class="s2">            &quot;&quot;&quot;</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">infos</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">CachedReplay</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ReplayCache.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayCache.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">path</span></div>


<div class="viewcode-block" id="ReplayDir"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDir">[docs]</a><span class="k">class</span> <span class="nc">ReplayDir</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A folder with replay files inside it.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Any files not ending in ``.osr`` are ignored.</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    Nested directories are not support (yet). Any folders encountered will be</span>
<span class="sd">    ignored.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">dir_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected path pointing to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span><span class="si">}</span><span class="s2"> to be&quot;</span>
                <span class="s2">&quot; a directory&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.osr&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">replay</span> <span class="o">=</span> <span class="n">ReplayPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">/</span> <span class="n">path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replay</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ReplayDir.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDir.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dir_path</span></div>


<div class="viewcode-block" id="Replay"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay">[docs]</a><span class="k">class</span> <span class="nc">Replay</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A replay played by a player.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight: :class:`~circleguard.utils.RatelimitWeight`</span>
<span class="sd">        How much it &#39;costs&#39; to load this replay from the api.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    game_version: :class:`~circleguard.game_version.GameVersion`</span>
<span class="sd">        Information about the version of osu! the replay was played on.</span>
<span class="sd">    timestamp: :class:`datetime.datetime`</span>
<span class="sd">        When the replay was played.</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The id of the map the replay was played on, or 0 if</span>
<span class="sd">        unknown or on an unsubmitted map.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The id of the player who played the replay, or 0 if unknown</span>
<span class="sd">        (if the player is restricted, for instance). Note that if the</span>
<span class="sd">        user id is known, even if the user is restricted, it should still be</span>
<span class="sd">        given instead of 0.</span>
<span class="sd">    username: str</span>
<span class="sd">        The username of the player who played the replay.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        The mods the replay was played with.</span>
<span class="sd">    replay_id: int</span>
<span class="sd">        The id of the replay, or 0 if the replay is unsubmitted.</span>
<span class="sd">    keydowns: ndarray[int]</span>
<span class="sd">        The keydowns for each frame of the replay. Keydowns are the keys pressed</span>
<span class="sd">        in that frame that were not pressed in the previous frame. See</span>
<span class="sd">        :meth:`~circleguard.loadables.Replay.keydowns` for more details.</span>
<span class="sd">    t: ndarray[int]</span>
<span class="sd">        A 1d array containing the timestamp for each frame.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    xy: ndarray[float]</span>
<span class="sd">        A 2d, two column array, containing the ``x`` and ``y`` coordinates of</span>
<span class="sd">        each frame in the first and second column respectively.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    k: ndarray[int]</span>
<span class="sd">        A 1d array containing the keys pressed for each frame.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span>

        <span class="c1"># These attributes might or might not be set once the replay loads.</span>
        <span class="c1"># Ideally, a replay would provide all of these attributes, but there are</span>
        <span class="c1"># some cases when only a subset is available.</span>
        <span class="c1">#</span>
        <span class="c1"># If only some of these attributes are set after the replay is loaded,</span>
        <span class="c1"># some ``Circleguard`` methods may reject this replay, as it does not</span>
        <span class="c1"># contain the information necessary to do whatever the method needs to.</span>
        <span class="c1">#</span>
        <span class="c1"># For instance, if the replay provides ``replay_data`` but not ``mods``,</span>
        <span class="c1"># ``Circleguard#similarity`` will reject it, as we will not know whether</span>
        <span class="c1"># whether ``Mod.HR`` was enabled on the replay, and thus whether to flip</span>
        <span class="c1"># the replay before comparing it to another one.</span>

        <span class="c1"># replays have no information about their game version by default.</span>
        <span class="c1"># Subclasses might set this if they have more information to provide</span>
        <span class="c1"># about their version, whether on instantiation or after being loaded.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">NoGameVersion</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span>    <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># declared as a property with a getter and setter so we can set</span>
        <span class="c1"># map_info&#39;s map_id attribute automatically</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># replays have no information about their map by default.</span>
        <span class="c1"># TODO: remove in core 6.0.0, in favor of ``Replay#map_available`` (and</span>
        <span class="c1"># possibly other mechanisms).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span>         <span class="o">=</span> <span class="n">MapInfo</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span>         <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span>          <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span>             <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span>        <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span>      <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_hash</span>      <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_300</span>        <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_100</span>        <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_50</span>         <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_geki</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_katu</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_miss</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span>            <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_combo</span>        <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_perfect_combo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">life_bar_graph</span>   <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng_seed</span>         <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pp</span>               <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># These attributes remain ``None``` when replay is unloaded, or loaded</span>
        <span class="c1"># but with no data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span>            <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>           <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span>            <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span>    <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">beatmap_available</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_library</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">)</span>

    <span class="c1"># TODO remove in core 6.0.0</span>
    <span class="n">map_available</span> <span class="o">=</span> <span class="n">beatmap_available</span>

<div class="viewcode-block" id="Replay.has_data"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay.has_data">[docs]</a>    <span class="k">def</span> <span class="nf">has_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether this replay has any replay data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether this replay has any replay data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If this replay is unloaded, it is guaranteed to not have any replay</span>
<span class="sd">        data. But if the replay is loaded, it is not guaranteed to have any</span>
<span class="sd">        replay data. Some replays do not have any replay data available from</span>
<span class="sd">        the api, even after being loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Replay.beatmap"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay.beatmap">[docs]</a>    <span class="k">def</span> <span class="nf">beatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The beatmap this replay was played on.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        library: :class:`slider.library.Library`</span>
<span class="sd">            The library used by the calling</span>
<span class="sd">            :class:`~circleguard.circleguard.Circleguard` instance. Beatmaps</span>
<span class="sd">            which have already been downloaded and are cached in this library</span>
<span class="sd">            may be returned here instead of redownloading them.</span>
<span class="sd">            |br|</span>
<span class="sd">            Beatmaps which we download or create in this method, but were not</span>
<span class="sd">            previously stored in the library, may also be stored into the</span>
<span class="sd">            library for future use as a result of calling this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`slider.beatmap.Beatmap`</span>
<span class="sd">            The beatmap this replay was played on.</span>
<span class="sd">        None</span>
<span class="sd">            If we do not know what beatmap this replay was played on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_available</span><span class="p">(</span><span class="n">library</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">library</span><span class="o">.</span><span class="n">lookup_by_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_process_replay_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Preprocesses the replay data (turns it into numpy arrays) for fast</span>
<span class="sd">        manipulation when investigating.</span>

<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">        replay_data: list[:class:`~osrparse.Replay.ReplayEvent`]</span>
<span class="sd">            A list of :class:`~osrparse.Replay.ReplayEvent` objects,</span>
<span class="sd">            representing the actual data of the replay. If the replay could not</span>
<span class="sd">            be loaded, this should be ``None``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method must be called before a replay can be considered loaded</span>
<span class="sd">        (ie before you set ``loaded`` to ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span>
        <span class="c1"># replay wasn&#39;t available, can&#39;t preprocess the data</span>
        <span class="k">if</span> <span class="n">replay_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># In rare cases (I&#39;m not quite sure how to reproduce), a replay&#39;s replay</span>
        <span class="c1"># data can be empty. We check this here to throw a clearer error</span>
        <span class="c1"># message than the IndexError we will get shortly after with</span>
        <span class="c1"># ``replay_data[0]``.</span>
        <span class="c1">#</span>
        <span class="c1"># Note that there&#39;s an important distinction between ``replay_data``</span>
        <span class="c1"># being ``None`` and being the empty list ``[]`` - the former means the</span>
        <span class="c1"># api (or osr, or some other source) had no replay data for this replay,</span>
        <span class="c1"># and the latter means it *had* replay data, it was just empty replay</span>
        <span class="c1"># data.</span>
        <span class="c1">#</span>
        <span class="c1"># It might be okay to just return as with the ``replay_data is None``</span>
        <span class="c1"># case, but I&#39;m erring on the side of caution and throwing for now.</span>
        <span class="c1">#</span>
        <span class="c1"># See https://github.com/circleguard/circleguard/issues/133 for examples</span>
        <span class="c1"># of replays exhibiting this behavior.</span>
        <span class="k">if</span> <span class="n">replay_data</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This replay&#39;s replay data was empty. This should &quot;</span>
                <span class="s2">&quot;not happen and is indicative of a misbehaved replay.&quot;</span><span class="p">)</span>

        <span class="c1"># TODO we&#39;ll want to add proper support for non-std replays at some</span>
        <span class="c1"># point, but for now we&#39;ll just drop the replay data and early return.</span>
        <span class="c1"># This results in identical behavior with previous versions of</span>
        <span class="c1"># circlecore, before osrparse supported non-std gamemodes.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">replay_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ReplayEventOsu</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="c1"># remove invalid zero time frame at beginning of replay</span>
        <span class="c1"># https://github.com/ppy/osu/blob/1587d4b26fbad691242544a62dbf017a78705</span>
        <span class="c1"># ae3/osu.Game/Scoring/Legacy/LegacyScoreDecoder.cs#L242-L245</span>
        <span class="k">if</span> <span class="n">replay_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time_delta</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># t, x, y, k</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="c1">## TODO try to use a peekable iterator to use an iter for above as well</span>
        <span class="c1"># use an iter an an optimization so we don&#39;t recreate the list when</span>
        <span class="c1"># taking (and removing) the first element</span>
        <span class="n">replay_data</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="c1"># The following comments in this method are guesswork, but seems to</span>
        <span class="c1"># accurately describe replays. This references the &quot;first&quot; frame</span>
        <span class="c1"># assuming that we have already removed the truly first zero time</span>
        <span class="c1"># frame, if it is present. So technically the &quot;first&quot; frame below may</span>
        <span class="c1"># be the second frame.</span>
        <span class="c1"># There are two possibilities for replays:</span>
        <span class="c1"># * for replays with a skip in the beginning, the first frame time is</span>
        <span class="c1">#   the skip duration. The next frame after that will have a negative</span>
        <span class="c1">#   time, to account for the replay data before the skip.</span>
        <span class="c1"># * for replays without a skip in the beginning, the first frame time</span>
        <span class="c1">#   is -1.</span>
        <span class="c1"># Since in the first case the first frame time is a large positive,</span>
        <span class="c1"># this would make ``highest_running_t`` large and cause all replay data</span>
        <span class="c1"># before the skip to be ignored. To solve this, we initialize</span>
        <span class="c1"># ``running_t`` to the first frame&#39;s time.</span>
        <span class="n">running_t</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span><span class="o">.</span><span class="n">time_delta</span>
        <span class="c1"># We consider negative time frames in the middle of replays to be</span>
        <span class="c1"># valid, with a caveat. Their negative time is counted toward</span>
        <span class="c1"># ``running_t`` (that is, decreases ``running_t``), but any frames</span>
        <span class="c1"># after it are ignored, until the total time passed of ignored frames</span>
        <span class="c1"># is greater than or equal to the negative frame.</span>
        <span class="c1"># There&#39;s one more catch - the frame that brings us *out* of this</span>
        <span class="c1"># &quot;negative time&quot; section where we&#39;re ignoring frames will cause a</span>
        <span class="c1"># special frame to be inserted, which has the same time as the frame</span>
        <span class="c1"># that brought us *into* the negative time section, and specially</span>
        <span class="c1"># calculated x and y positions. Details below.</span>
        <span class="c1"># I do not know why stable treats negative time frames in this way.</span>
        <span class="c1"># It is not what lazer does, as far as I can tell. But it is the only</span>
        <span class="c1"># reasonable explanation for stable behavior. This solution may not,</span>
        <span class="c1"># however, be the canonical solution.</span>
        <span class="n">highest_running_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span>
        <span class="c1"># The last positive frame we encountered before entering a negative</span>
        <span class="c1"># section.</span>
        <span class="n">last_positive_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># the running time when we encountered ``last_positive_frame``. We need</span>
        <span class="c1"># to save this as we do not store this information in each individual</span>
        <span class="c1"># frame.</span>
        <span class="n">last_positive_frame_cum_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">previous_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">replay_data</span><span class="p">:</span>
            <span class="c1"># check if we were in a negative section of the play at the</span>
            <span class="c1"># previous frame (f0) before applying the current frame (f1), so we</span>
            <span class="c1"># can apply special logic if f1 is the frame that gets us out of</span>
            <span class="c1"># the negative section.</span>
            <span class="n">was_in_negative_section</span> <span class="o">=</span> <span class="n">running_t</span> <span class="o">&lt;</span> <span class="n">highest_running_t</span>

            <span class="n">e_t</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">time_delta</span>
            <span class="n">running_t</span> <span class="o">+=</span> <span class="n">e_t</span>
            <span class="n">highest_running_t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">highest_running_t</span><span class="p">,</span> <span class="n">running_t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">running_t</span> <span class="o">&lt;</span> <span class="n">highest_running_t</span><span class="p">:</span>
                <span class="c1"># if we weren&#39;t in a negative section in f0, f1 is the first</span>
                <span class="c1"># frame to bring us into one, so f0 is the last positive frame.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">was_in_negative_section</span><span class="p">:</span>
                    <span class="n">last_positive_frame</span> <span class="o">=</span> <span class="n">previous_frame</span>
                    <span class="c1"># we want to set it to the cumulative time before f1</span>
                    <span class="c1"># was processed, so subtract out the current e_t</span>
                    <span class="n">last_positive_frame_cum_time</span> <span class="o">=</span> <span class="n">running_t</span> <span class="o">-</span> <span class="n">e_t</span>
                <span class="n">previous_frame</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">continue</span>

            <span class="c1"># if we get here, f1 brought us out of the negative section. In</span>
            <span class="c1"># this case, osu! actually inserts a new frame, with:</span>
            <span class="c1"># * t = the cumulative time at the last positive frame (yes, this</span>
            <span class="c1">#   means there are two frames at the same time in the replay</span>
            <span class="c1">#   playback).</span>
            <span class="c1"># * x, y = a weighted average between the positions of f0 and f1,</span>
            <span class="c1">#   weighted by how close the last positive frame&#39;s time is to each</span>
            <span class="c1">#   of the two frames&#39; times.</span>
            <span class="c1"># * k = the keypresses of the last positive frame.</span>
            <span class="k">if</span> <span class="n">was_in_negative_section</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">)</span>

                <span class="c1"># this is [running_t at f0, running_t at f1], to interpolate</span>
                <span class="c1"># the last positive frame&#39;s time between.</span>
                <span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="n">running_t</span> <span class="o">-</span> <span class="n">e_t</span><span class="p">,</span> <span class="n">running_t</span><span class="p">]</span>

                <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="n">previous_frame</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="n">previous_frame</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

                <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_positive_frame</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>

            <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_t</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="c1"># TODO: are we taking a performance hit here by letting osrparse</span>
            <span class="c1"># convert keys to an enum in its replay&#39;s init, then converting it</span>
            <span class="c1"># back to an int here (since it&#39;s faster for us to work with raw</span>
            <span class="c1"># ints)?</span>
            <span class="c1"># We could add a ``fast_parse`` option to osrparse which doesn&#39;t</span>
            <span class="c1"># use nice things like enums if this turns out to be a performance</span>
            <span class="c1"># issue.</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">keys</span><span class="p">))</span>
            <span class="n">previous_frame</span> <span class="o">=</span> <span class="n">e</span>

        <span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># sort our data by t. Stable so we don&#39;t reorder frames with equal</span>
        <span class="c1"># times</span>
        <span class="n">t_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;stable&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">beatmap_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id</span>

    <span class="nd">@beatmap_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">beatmap_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beatmap_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>

    <span class="c1"># TODO remove in core 6.0.0</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">map_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id</span>

    <span class="nd">@map_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">map_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beatmap_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">keydowns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of the keys pressed for each frame that were not pressed in the</span>
<span class="sd">        previous frame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        If the first frame (``f1``) has keys ``K1`` and ``f2`` has keys</span>
<span class="sd">        ``K1 + K2``, then ``keydowns[1]`` is ``K2``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># can&#39;t do `if not self._keydowns` because the truth value of an</span>
        <span class="c1"># ndarray is ambiguous</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keypresses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">&amp;</span> <span class="n">KEY_MASK</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span> <span class="o">=</span> <span class="n">keypresses</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">keypresses</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Replay(timestamp=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;beatmap_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">,user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,replay_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="si">}</span><span class="s2">,weight=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">,username=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Replay by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="ReplayMap"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayMap">[docs]</a><span class="k">class</span> <span class="nc">ReplayMap</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` that was submitted to online servers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The id of the map the replay was played on.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The id of the player who played the replay.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        The mods the replay was played with. If ``None``, the</span>
<span class="sd">        highest scoring replay of ``user_id`` on ``map_id`` will be loaded,</span>
<span class="sd">        regardless of mod combination. Otherwise, the replay with ``mods``</span>
<span class="sd">        will be loaded.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is unloaded:</span>

<span class="sd">    * beatmap_id</span>
<span class="sd">    * user_id</span>
<span class="sd">    * mods (if passed)</span>

<span class="sd">    In addition to the above, the following replay-related attributes are</span>
<span class="sd">    available (not ``None``) when this replay is loaded:</span>

<span class="sd">    * timestamp</span>
<span class="sd">    * username</span>
<span class="sd">    * mods</span>
<span class="sd">    * replay_id</span>
<span class="sd">    * count_300</span>
<span class="sd">    * count_100</span>
<span class="sd">    * count_50</span>
<span class="sd">    * count_geki</span>
<span class="sd">    * count_katu</span>
<span class="sd">    * count_miss</span>
<span class="sd">    * score</span>
<span class="sd">    * max_combo</span>
<span class="sd">    * is_perfect_combo</span>
<span class="sd">    * pp</span>
<span class="sd">    * replay_data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beatmap_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">HEAVY</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.ReplayMap&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">date</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">beatmap_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">username</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span>

        <span class="c1"># TODO remove in core 6.0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span>

<div class="viewcode-block" id="ReplayMap.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayMap.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the data for this replay from the api.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~.loader.Loader`</span>
<span class="sd">            The :class:`~.loader.Loader` to load this replay with.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache this replay after loading it. This only has an</span>
<span class="sd">            effect if ``self.cache`` is unset (``None``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># only listen to the parent&#39;s cache if ours is not set. Lower takes</span>
        <span class="c1"># precedence</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> already loaded, not loading&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">loader</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A ReplayMap cannot be loaded without api access&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">,</span> <span class="n">user_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
                <span class="n">mods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">date</span>
        <span class="c1"># estimate version with timestamp, this is only accurate if the user</span>
        <span class="c1"># keeps their game up to date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">GameVersion</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
            <span class="n">concrete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">username</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_100</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">count_100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_300</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">count_300</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_50</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">count_50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_geki</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">count_geki</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_katu</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">count_katu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_miss</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">count_miss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_combo</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">max_combo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_perfect_combo</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">perfect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">pp</span>

        <span class="n">replay_data</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_data</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;Finished loading </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the two replay maps are equal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This does not take into account the</span>
<span class="sd">        ``cache`` attribute, because equality here means &quot;do they represent the</span>
<span class="sd">        same replays&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayMap</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">()</span> <span class="ow">and</span> <span class="n">loadable</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ReplayMap(timestamp=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;beatmap_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">,user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,cache=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="si">}</span><span class="s2">,replay_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">,username=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ReplayMap(beatmap_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,cache=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="si">}</span><span class="s2">,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Loaded&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;Unloaded&#39;</span><span class="si">}</span><span class="s2"> ReplayMap by &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayDataOSR"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDataOSR">[docs]</a><span class="k">class</span> <span class="nc">ReplayDataOSR</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` which has been saved in the osr format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight: :class:`~circleguard.utils.RatelimitWeight`</span>
<span class="sd">        How much it &#39;costs&#39; to load this replay from the api.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ReplayDataStrings have no replay-related attributes available (not ``None``)</span>
<span class="sd">    when they are unloaded.</span>

<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is loaded:</span>

<span class="sd">    * timestamp</span>
<span class="sd">    * beatmap_id</span>
<span class="sd">    * username</span>
<span class="sd">    * user_id</span>
<span class="sd">    * mods</span>
<span class="sd">    * replay_id</span>
<span class="sd">    * beatmap_hash</span>
<span class="sd">    * replay_hash</span>
<span class="sd">    * count_300</span>
<span class="sd">    * count_100</span>
<span class="sd">    * count_50</span>
<span class="sd">    * count_geki</span>
<span class="sd">    * count_katu</span>
<span class="sd">    * count_miss</span>
<span class="sd">    * score</span>
<span class="sd">    * max_combo</span>
<span class="sd">    * is_perfect_combo</span>
<span class="sd">    * life_bar_graph (currently unparsed)</span>
<span class="sd">    * replay_data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ratelimit_weight</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ratelimit_weight</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.ReplayPath&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id_func</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ReplayDataOSR.beatmap"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDataOSR.beatmap">[docs]</a>    <span class="k">def</span> <span class="nf">beatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_available</span><span class="p">(</span><span class="n">library</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># if we can&#39;t load our beatmap_id, fall back to loading from slider.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_load_api_attributes</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">library</span><span class="o">.</span><span class="n">lookup_by_md5</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">beatmap</span><span class="p">(</span><span class="n">library</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">beatmap_available</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
        <span class="n">beatmap_cached</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="n">beatmap_cached</span><span class="p">(</span><span class="n">beatmap_md5</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="ow">and</span> <span class="n">beatmap_cached</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">beatmap_available</span><span class="p">(</span><span class="n">library</span><span class="p">)</span>

<div class="viewcode-block" id="ReplayDataOSR.load_from_osrparse_replay"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDataOSR.load_from_osrparse_replay">[docs]</a>    <span class="k">def</span> <span class="nf">load_from_osrparse_replay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">_cache</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the data for this replay from the already loaded osrparse replay.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~.loader.Loader`</span>
<span class="sd">            The :class:`~.loader.Loader` to load this replay with.</span>
<span class="sd">            |br|</span>
<span class="sd">            If ``None``, this replay will be unable to retrieve its ``map_id``</span>
<span class="sd">            or ``user_id``, but everything else will still be loaded.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache this replay after loading it. This only has an</span>
<span class="sd">            effect if ``self.cache`` is unset (``None``). Note that currently</span>
<span class="sd">            we do not cache :class:`~.ReplayPath` regardless of this parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">GameVersion</span><span class="p">(</span><span class="n">replay</span><span class="o">.</span><span class="n">game_version</span><span class="p">,</span> <span class="n">concrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">beatmap_hash</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">username</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_hash</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">replay_hash</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_300</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">count_300</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_100</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">count_100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_50</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">count_50</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_geki</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">count_geki</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_katu</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">count_katu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_miss</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">count_miss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_combo</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">max_combo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_perfect_combo</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">perfect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">replay</span><span class="o">.</span><span class="n">mods</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">life_bar_graph</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">life_bar_graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">replay_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng_seed</span> <span class="o">=</span> <span class="n">replay</span><span class="o">.</span><span class="n">rng_seed</span>

        <span class="k">if</span> <span class="n">loader</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">user_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id_func</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">beatmap_id</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">replay</span><span class="o">.</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">&quot;Finished loading </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">load_from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="n">replay</span> <span class="o">=</span> <span class="n">osrparse</span><span class="o">.</span><span class="n">Replay</span><span class="o">.</span><span class="n">from_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_from_osrparse_replay</span><span class="p">(</span><span class="n">replay</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_data_str</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="n">replay</span> <span class="o">=</span> <span class="n">osrparse</span><span class="o">.</span><span class="n">Replay</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">replay_data_str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_from_osrparse_replay</span><span class="p">(</span><span class="n">replay</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The map if of a replay which has been loaded &quot;</span>
                <span class="s2">&quot;without a ``Loader`` cannot be retrieved.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">beatmap_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id_func</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The map id of a replay which has been loaded &quot;</span>
                <span class="s2">&quot;without a ``Loader`` cannot be retrieved. This can happen if &quot;</span>
                <span class="s2">&quot;the replay was loaded with a ``KeylessCircleguard``.&quot;</span><span class="p">)</span>
        <span class="c1"># property inheritence is a bit nasty. See</span>
        <span class="c1"># https://stackoverflow.com/a/37663266 for reference</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">:</span>
            <span class="n">beatmap_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ReplayDataOSR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">beatmap_id</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">beatmap_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">beatmap_id</span>

    <span class="nd">@beatmap_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">beatmap_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beatmap_id</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ReplayDataOSR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">beatmap_id</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beatmap_id</span><span class="p">)</span>

    <span class="c1"># TODO remove in core 6.0.0</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">map_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id_func</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The map id of a replay which has been loaded &quot;</span>
                <span class="s2">&quot;without a ``Loader`` cannot be retrieved. This can happen if &quot;</span>
                <span class="s2">&quot;the replay was loaded with a ``KeylessCircleguard``.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">beatmap_id</span><span class="p">:</span>
            <span class="n">beatmap_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ReplayDataOSR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">beatmap_id</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">beatmap_id</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">beatmap_id</span>

    <span class="nd">@map_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">map_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ReplayDataOSR</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span><span class="o">.</span><span class="n">map_id</span><span class="o">.</span><span class="n">fset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">)</span>

<div class="viewcode-block" id="ReplayDataOSR.can_load_api_attributes"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDataOSR.can_load_api_attributes">[docs]</a>    <span class="k">def</span> <span class="nf">can_load_api_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether we can load attributes that are lazy loaded and require api</span>
<span class="sd">        calls, such as ``map_id`` or ``user_id``, if requested.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id_func</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReplayDataOSR.api_attributes_loaded"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDataOSR.api_attributes_loaded">[docs]</a>    <span class="k">def</span> <span class="nf">api_attributes_loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether attributes that are lazy loaded and require api calls, such as</span>
<span class="sd">        ``map_id`` or ``user_id``, have already been loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span><span class="p">)</span></div>


    <span class="nd">@user_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="n">user_id</span></div>


<div class="viewcode-block" id="ReplayPath"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayPath">[docs]</a><span class="k">class</span> <span class="nc">ReplayPath</span><span class="p">(</span><span class="n">ReplayDataOSR</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` saved locally in a ``.osr`` file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str or :class:`os.PathLike`</span>
<span class="sd">        The path to the replay file.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that currently</span>
<span class="sd">        we do not cache :class:`~.ReplayPath` regardless of this parameter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ReplayPaths have no replay-related attributes available (not ``None``) when</span>
<span class="sd">    they are unloaded.</span>

<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is loaded:</span>

<span class="sd">    * timestamp</span>
<span class="sd">    * beatmap_id</span>
<span class="sd">    * username</span>
<span class="sd">    * user_id</span>
<span class="sd">    * mods</span>
<span class="sd">    * replay_id</span>
<span class="sd">    * beatmap_hash</span>
<span class="sd">    * replay_hash</span>
<span class="sd">    * count_300</span>
<span class="sd">    * count_100</span>
<span class="sd">    * count_50</span>
<span class="sd">    * count_geki</span>
<span class="sd">    * count_katu</span>
<span class="sd">    * count_miss</span>
<span class="sd">    * score</span>
<span class="sd">    * max_combo</span>
<span class="sd">    * is_perfect_combo</span>
<span class="sd">    * life_bar_graph (currently unparsed)</span>
<span class="sd">    * replay_data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">LIGHT</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.ReplayPath&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_beatmap_id_func</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ReplayPath.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayPath.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loading ReplayPath </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> already loaded, not loading&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether these replay paths are equal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If one or both replay paths don&#39;t have replay data, this checks path</span>
<span class="sd">        equality. If both replay paths have replay data, this checks the</span>
<span class="sd">        equality of their replay data.</span>
<span class="sd">        |br|</span>
<span class="sd">        The reason we don&#39;t check path after both are loaded is to avoid</span>
<span class="sd">        true in situations like this:</span>

<span class="sd">        ```</span>
<span class="sd">        r1 = ReplayPath(&quot;./1.osr&quot;)</span>
<span class="sd">        cg.load(r1)</span>
<span class="sd">        # change the file located at ./1.osr to another osr file</span>
<span class="sd">        r2 = ReplayPath(&quot;./1.osr&quot;)</span>
<span class="sd">        cg.load(r2)</span>
<span class="sd">        r1 == r2 # should be False, as they have differing replay data</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayPath</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">()</span> <span class="ow">and</span> <span class="n">loadable</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">path</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="n">api_attrs_string</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span>
            <span class="c1"># avoid loading these lazy-loaded attributes by accessing them here,</span>
            <span class="c1"># unless they&#39;re already loaded</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">api_attributes_loaded</span><span class="p">():</span>
                <span class="n">api_attrs_string</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;beatmap_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ReplayPath(path=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">api_attrs_string</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,replay_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;weight=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2">,loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;username=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ReplayPath(path=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">,weight=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded ReplayPath by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2"> on &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Unloaded ReplayPath at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="ReplayString"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayString">[docs]</a><span class="k">class</span> <span class="nc">ReplayString</span><span class="p">(</span><span class="n">ReplayDataOSR</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` saved locally in a ``.osr`` file, when the file has</span>
<span class="sd">    already been read as a string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    replay_data_str: str</span>
<span class="sd">        The contents of the replay file as a string.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that currently</span>
<span class="sd">        we do not cache :class:`~.ReplayString` regardless of this parameter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ReplayPaths have no replay-related attributes available (not ``None``) when</span>
<span class="sd">    they are unloaded.</span>

<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is loaded:</span>

<span class="sd">    * timestamp</span>
<span class="sd">    * beatmap_id</span>
<span class="sd">    * username</span>
<span class="sd">    * user_id</span>
<span class="sd">    * mods</span>
<span class="sd">    * replay_id</span>
<span class="sd">    * beatmap_hash</span>
<span class="sd">    * replay_hash</span>
<span class="sd">    * count_300</span>
<span class="sd">    * count_100</span>
<span class="sd">    * count_50</span>
<span class="sd">    * count_geki</span>
<span class="sd">    * count_katu</span>
<span class="sd">    * count_miss</span>
<span class="sd">    * score</span>
<span class="sd">    * max_combo</span>
<span class="sd">    * is_perfect_combo</span>
<span class="sd">    * life_bar_graph (currently unparsed)</span>
<span class="sd">    * replay_data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; replay_data = open(&quot;replay.osr&quot;, &quot;rb&quot;).read()</span>
<span class="sd">    &gt;&gt;&gt; r = ReplayString(replay_data)</span>
<span class="sd">    &gt;&gt;&gt; cg.load(r)</span>
<span class="sd">    &gt;&gt;&gt; print(cg.ur(r))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_data_str</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">LIGHT</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;.ReplayString&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span> <span class="o">=</span> <span class="n">replay_data_str</span>

<div class="viewcode-block" id="ReplayString.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayString.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_from_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayString</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data_str</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="n">api_attrs_string</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">api_attributes_loaded</span><span class="p">():</span>
                <span class="n">api_attrs_string</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;beatmap_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ReplayString(len(replay_data_str)=&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">api_attrs_string</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;replay_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="si">}</span><span class="s2">,weight=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2">,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">,username=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;ReplayString(len(replay_data_str)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded ReplayString by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2"> on &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unloaded ReplayString with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;chars of data&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayID"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayID">[docs]</a><span class="k">class</span> <span class="nc">ReplayID</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`~.Replay` that was submitted online and is represented by a unique</span>
<span class="sd">    replay id.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    replay_id: int</span>
<span class="sd">        The id of the replay.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that we currently</span>
<span class="sd">        do not cache ReplayIDs.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is unloaded:</span>

<span class="sd">    * replay_id</span>

<span class="sd">    In addition to the above, the following replay-related attributes are</span>
<span class="sd">    available (not ``None``) when this replay is loaded:</span>

<span class="sd">    * replay_data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_id</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">HEAVY</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">replay_id</span>

<div class="viewcode-block" id="ReplayID.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayID.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">loader</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A ReplayID cannot be loaded without api access&quot;</span><span class="p">)</span>
        <span class="c1"># TODO file github issue about loading info from replay id, right now we</span>
        <span class="c1"># can literally only load the replay data which isn&#39;t that useful</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="n">replay_data</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_data_from_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">replay_id</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">)</span></div>


<div class="viewcode-block" id="CachedReplay"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.CachedReplay">[docs]</a><span class="k">class</span> <span class="nc">CachedReplay</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is intended to be instantiated from</span>
<span class="sd">    :func:`~.ReplayCache.load_info` and should not be instantiated manually.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">beatmap_id</span><span class="p">,</span> <span class="n">mods</span><span class="p">,</span> <span class="n">replay_data</span><span class="p">,</span> <span class="n">replay_id</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">mods</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">replay_id</span>

        <span class="c1"># TODO remove in core 6.0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">beatmap_id</span>

<div class="viewcode-block" id="CachedReplay.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.CachedReplay.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">decompressed</span> <span class="o">=</span> <span class="n">wtc</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="n">replay_data</span> <span class="o">=</span> <span class="n">osrparse</span><span class="o">.</span><span class="n">parse_replay_data</span><span class="p">(</span><span class="n">decompressed</span><span class="p">,</span> <span class="n">decoded</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">replay_id</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="ReplayOssapi"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayOssapi">[docs]</a><span class="k">class</span> <span class="nc">ReplayOssapi</span><span class="p">(</span><span class="n">ReplayDataOSR</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a :module:`ossapi` replay to a circlecore :class:`~.Replay`.</span>
<span class="sd">    Requires ossapi to be installed (you can&#39;t get an ossapi replay without</span>
<span class="sd">    having ossapi installed anyway).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ossapi_replay</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="kn">import</span> <span class="nn">ossapi</span>
        <span class="n">game_mode_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ossapi</span><span class="o">.</span><span class="n">GameMode</span><span class="o">.</span><span class="n">OSU</span><span class="p">:</span>    <span class="n">osrparse</span><span class="o">.</span><span class="n">GameMode</span><span class="o">.</span><span class="n">STD</span><span class="p">,</span>
            <span class="n">ossapi</span><span class="o">.</span><span class="n">GameMode</span><span class="o">.</span><span class="n">TAIKO</span><span class="p">:</span>  <span class="n">osrparse</span><span class="o">.</span><span class="n">GameMode</span><span class="o">.</span><span class="n">TAIKO</span><span class="p">,</span>
            <span class="n">ossapi</span><span class="o">.</span><span class="n">GameMode</span><span class="o">.</span><span class="n">CATCH</span><span class="p">:</span>  <span class="n">osrparse</span><span class="o">.</span><span class="n">GameMode</span><span class="o">.</span><span class="n">CTB</span><span class="p">,</span>
            <span class="n">ossapi</span><span class="o">.</span><span class="n">GameMode</span><span class="o">.</span><span class="n">MANIA</span><span class="p">:</span>  <span class="n">osrparse</span><span class="o">.</span><span class="n">GameMode</span><span class="o">.</span><span class="n">MANIA</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># an ossapi replay is almost identical to an osrparse replay, except</span>
        <span class="c1"># it has a different gamemode and mod enum.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">osrparse_replay</span> <span class="o">=</span> <span class="n">osrparse</span><span class="o">.</span><span class="n">Replay</span><span class="p">(</span>
            <span class="n">game_mode_map</span><span class="p">[</span><span class="n">ossapi_replay</span><span class="o">.</span><span class="n">mode</span><span class="p">],</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">game_version</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">replay_hash</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">count_300</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">count_100</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">count_50</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">count_geki</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">count_katu</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">count_miss</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">score</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">max_combo</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">perfect</span><span class="p">,</span>
            <span class="n">osrparse</span><span class="o">.</span><span class="n">Mod</span><span class="p">(</span><span class="n">ossapi_replay</span><span class="o">.</span><span class="n">mods</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">life_bar_graph</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">replay_data</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">replay_id</span><span class="p">,</span>
            <span class="n">ossapi_replay</span><span class="o">.</span><span class="n">rng_seed</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ReplayOssapi.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayOssapi.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_from_osrparse_replay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">osrparse_replay</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayOssapi</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">osrparse_replay</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">osrparse_replay</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">osrparse_replay</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded ReplayOssapi by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2"> on &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unloaded ReplayOssapi by </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">)</span><span class="si">}</span><span class="s2"> on beatmap &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;hash </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            Made with 
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    </body>
</html>