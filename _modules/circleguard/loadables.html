<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <meta name="generator" content="sphinx-3.5.2, furo 2021.03.20.beta30"/>
        <title>circleguard.loadables - Circleguard v5.1.2 documentation</title>
      <link rel="stylesheet" href="../../_static/styles/furo.css?digest=978e1795dfe158b585dda6a8417f6411828bf3ed">
    <link rel="stylesheet" href="../../_static/pygments.css">
    <link media="(prefers-color-scheme: dark)" rel="stylesheet" href="../../_static/pygments_dark.css">
    


<style>
  :root {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media (prefers-color-scheme: dark) {
    :root {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
  }

  /* For allowing end-user-specific overrides */
  .override-light {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  .override-dark {
    --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
  }
</style><link rel="stylesheet" href="../../_static/styles/furo-extensions.css?digest=d391b54134226e4196576da3bdb6dddb7e05ba2b"></head>
  <body dir="">
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke-width="1.5" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z"/>
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
      class="feather feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Circleguard v5.1.2 documentation</div></a>
    </div>
    <div class="header-right">
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Circleguard v5.1.2 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html">
  <input class="sidebar-search" placeholder=Search name="q">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Circlecore</a></li>
</ul>
<p class="caption"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../foreword.html">Foreword</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../representing-replays.html">Representing Replays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../using-circleguard.html">Using Circleguard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../replay-containers.html"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReplayContainer</span></code>s</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../loading.html">Loading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../caching.html">Caching</a></li>
</ul>
<p class="caption"><span class="caption-text">Contributing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../appendix.html">Appendix</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <main class="main">
    <div class="content">
      <article role="main">
        <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
          <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
        </label>
        <h1>Source code for circleguard.loadables</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">abc</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">import</span> <span class="nn">osrparse</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">wtc</span>

<span class="kn">from</span> <span class="nn">circleguard</span> <span class="kn">import</span> <span class="n">Mod</span>
<span class="kn">from</span> <span class="nn">circleguard.utils</span> <span class="kn">import</span> <span class="n">TRACE</span><span class="p">,</span> <span class="n">KEY_MASK</span><span class="p">,</span> <span class="n">RatelimitWeight</span>
<span class="kn">from</span> <span class="nn">circleguard.loader</span> <span class="kn">import</span> <span class="n">Loader</span>
<span class="kn">from</span> <span class="nn">circleguard.span</span> <span class="kn">import</span> <span class="n">Span</span>
<span class="kn">from</span> <span class="nn">circleguard.game_version</span> <span class="kn">import</span> <span class="n">GameVersion</span><span class="p">,</span> <span class="n">NoGameVersion</span>
<span class="kn">from</span> <span class="nn">circleguard.map_info</span> <span class="kn">import</span> <span class="n">MapInfo</span>


<div class="viewcode-block" id="Loadable"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Loadable">[docs]</a><span class="k">class</span> <span class="nc">Loadable</span><span class="p">(</span><span class="n">abc</span><span class="o">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Represents one or multiple replays, which have replay data to be loaded</span>
<span class="sd">    from some additional source - the osu! api, local cache, or some other</span>
<span class="sd">    location.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replay data once loaded.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span>

<div class="viewcode-block" id="Loadable.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Loadable.load">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loads the information this loadable needs to become fully loaded.</span>
<span class="sd">        Details left to the subclass implementation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~circleguard.loader.Loader`</span>
<span class="sd">            The loader to load this loadable with. Although subclasses may not</span>
<span class="sd">            end up using a :class:`~circleguard.loader.Loader` to load</span>
<span class="sd">            themselves (if they don't load anything from the osu api, for</span>
<span class="sd">            instance), a loader is still passed regardless.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache the replay data once loaded. This argument</span>
<span class="sd">            comes from a parentâ€”either a :class:`~.ReplayContainer` or</span>
<span class="sd">            :class:`~circleguard.circleguard.Circleguard` itself. Should the</span>
<span class="sd">            loadable already have a set ``cache`` value, that should take</span>
<span class="sd">            precedence over the option passed in this method, but if the</span>
<span class="sd">            loadable has no preference then it should respect the value passed</span>
<span class="sd">            here.</span>
<span class="sd">        """</span>
        <span class="k">pass</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="LoadableContainer"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer">[docs]</a><span class="k">class</span> <span class="nc">LoadableContainer</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A Loadable that holds Loadables, which may be ``ReplayContainer``\s or</span>
<span class="sd">    ``Replay``\s.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    loadables: list[:class:`~.Loadable`]</span>
<span class="sd">        The loadables to hold.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the loadables once they are loaded. This will be</span>
<span class="sd">        overriden by a ``cache`` option set by a :class:`~Loadable` in</span>
<span class="sd">        ``loadables``. This only affects child loadables when they do not have</span>
<span class="sd">        a ``cache`` option set.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class is intended for situations when you have a list of replays and</span>
<span class="sd">    replay containers, but no way to separate or distinguish them. If you want</span>
<span class="sd">    to get, say, all the replays out of that list (whether they come from</span>
<span class="sd">    replay subclasses already in the list, or the replays held by a replay</span>
<span class="sd">    container in the list), this loadable container class has the logic to do</span>
<span class="sd">    that for you:</span>

<span class="sd">    &gt;&gt;&gt; lc = LoadableContainer(mixed_loadable_list)</span>
<span class="sd">    &gt;&gt;&gt; replays = lc.all_replays()</span>

<span class="sd">    It can also be useful to info load the replay containers in the list,</span>
<span class="sd">    without first filtering the list to remove any replay subclasses:</span>

<span class="sd">    &gt;&gt;&gt; cg.load_info(lc)</span>
<span class="sd">    &gt;&gt;&gt; # all loadable containers in the list are now info loaded</span>
<span class="sd">    &gt;&gt;&gt; cg.load(lc)</span>
<span class="sd">    &gt;&gt;&gt; # all loadables in the list are now loaded</span>

<span class="sd">    You are very unlikely to want to subclass this class. If you want to add a</span>
<span class="sd">    new loadable that holds replays, subclass ``ReplayContainer``.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadables</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span> <span class="o">=</span> <span class="n">loadables</span>

<div class="viewcode-block" id="LoadableContainer.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        All the :class:`~.Replay`\s in this loadable container.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[:class:`~Replay`]</span>
<span class="sd">            All the replays in this loadable container.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This list may be incomplete if you do not call</span>
<span class="sd">        :meth:`~circleguard.circleguard.Circleguard.load_info` on this loadable</span>
<span class="sd">        container first, as any replay containers held in this container will</span>
<span class="sd">        likely not have references to their replays yet.</span>
<span class="sd">        """</span>
        <span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayContainer</span><span class="p">):</span>
                <span class="n">replays</span> <span class="o">+=</span> <span class="n">loadable</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># loadable is a Replay if it's not a ReplayContainer</span>
                <span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loadable</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">replays</span></div>

<div class="viewcode-block" id="LoadableContainer.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.LoadableContainer.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="n">cascade_cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="n">loadable</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">cascade_cache</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">loadable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayContainer</span><span class="p">):</span>
                <span class="n">loadable</span><span class="o">.</span><span class="n">load_info</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">LoadableContainer</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loadables</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayContainer"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer">[docs]</a><span class="k">class</span> <span class="nc">ReplayContainer</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A Loadable that holds Replay subclasses, and which has an additional state</span>
<span class="sd">    between "unloaded" and "loaded" called "info loaded".</span>

<span class="sd">    ReplayContainers start unloaded and become info loaded when</span>
<span class="sd">    :meth:`~circleguard.circleguard.Circleguard.load_info` is called. They</span>
<span class="sd">    become fully loaded when :meth:`~.circleguard.circleguard.Circleguard.load`</span>
<span class="sd">    is called (and if this is called when the ReplayContainer is in the unloaded</span>
<span class="sd">    state, :meth:`~Loadable.load` will load info first, then load the replays,</span>
<span class="sd">    effectively skipping the info loaded state).</span>

<span class="sd">    In the unloaded state, the container has no actual Replay objects. It may</span>
<span class="sd">    have limited knowledge about their number or type.</span>

<span class="sd">    In the info loaded state, the container has references to Replay objects,</span>
<span class="sd">    but those Replay objects are unloaded.</span>

<span class="sd">    In the loaded state, the Replay objects in the container are loaded.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="ReplayContainer.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loads all :class:`~circleguard.loadables.Loadable`\s contained by this</span>
<span class="sd">        loadable container.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~circleguard.loader.Loader`</span>
<span class="sd">            The loader to load the :class:`~circleguard.loadables.Loadable`\s</span>
<span class="sd">            with.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">cascade_cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_info</span><span class="p">(</span><span class="n">loader</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">replay</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">():</span>
            <span class="n">replay</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">cascade_cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="ReplayContainer.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayContainer.all_replays">[docs]</a>    <span class="nd">@abc</span><span class="o">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Returns all the :class:`~.Replay`\s in this loadable container.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        If you want an accurate list of :class:`~.Replay`\s in this instance,</span>
<span class="sd">        you must call :func:`~circleguard.circleguard.Circleguard.load_info` on</span>
<span class="sd">        this instance before</span>
<span class="sd">        :func:`~circleguard.loadables.ReplayContainer.all_replays`. Otherwise,</span>
<span class="sd">        this instance is not info loaded, and does not have a complete list of</span>
<span class="sd">        replays it represents.</span>
<span class="sd">        """</span>
        <span class="k">pass</span></div>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">replays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">replays</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">start</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span><span class="n">key</span><span class="o">.</span><span class="n">step</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">replays</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_replays</span><span class="p">())</span></div>


<div class="viewcode-block" id="Map"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Map">[docs]</a><span class="k">class</span> <span class="nc">Map</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A map's top plays (leaderboard), as seen on the website.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The map to represent the top plays for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of top plays to retrieve.</span>
<span class="sd">        ``span="1-3,6,2-4"`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        If passed, only represent replays played with this exact mod</span>
<span class="sd">        combination. Due to limitations with the api, fuzzy matching is not</span>
<span class="sd">        implemented.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is applied before ``span``. That is, if ``span="1-2"``</span>
<span class="sd">        and ``mods=Mod.HD``, the top two ``HD`` plays on the map are</span>
<span class="sd">        represented.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span>
            <span class="n">mods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span>
                <span class="n">cache</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Map.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Map.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">map_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"Map(map_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">,cache=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="si">}</span><span class="s2">,mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"span=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="si">}</span><span class="s2">,replays=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"Map </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">"</span></div>


<div class="viewcode-block" id="User"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.User">[docs]</a><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A user's top plays (pp-wise, as seen on the website).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The user to represent the top plays for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of top plays to retrieve.</span>
<span class="sd">        ``span="1-3,6,2-4"`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        If passed, only represent replays played with this exact mod</span>
<span class="sd">        combination. Due to limitations with the api, fuzzy matching is not</span>
<span class="sd">        implemented.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is applied before ``span``. That is, if ``span="1-2"``</span>
<span class="sd">        and ``mods=Mod.HD``, the user's top two ``HD`` plays are represented.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    available_only: bool</span>
<span class="sd">        Whether to represent only replays that have replay data available.</span>
<span class="sd">        Replays are filtered on this basis after ``mods`` and ``span``</span>
<span class="sd">        are applied. True by default.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">span</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> \
        <span class="n">available_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="o">=</span> <span class="n">available_only</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_user_best</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_available</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="User.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.User.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">User</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapUser"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.MapUser">[docs]</a><span class="k">class</span> <span class="nc">MapUser</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    All replays on a map by a user, not just the top replay.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The map to represent scores by `user_id` on.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The user to represent scores on `map_id` for.</span>
<span class="sd">    span: str or Span</span>
<span class="sd">        A comma separated list of ranges of plays to retrieve.</span>
<span class="sd">        ``span="1-3,6,2-4"`` -&gt; replays in the range ``[1,2,3,4,6]``.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache the replays once they are loaded.</span>
<span class="sd">    available_only: bool</span>
<span class="sd">        Whether to represent only replays that have replay data available.</span>
<span class="sd">        Replays are filtered on this basis after ``span`` is applied.</span>
<span class="sd">        True by default.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="n">Loader</span><span class="o">.</span><span class="n">MAX_MAP_SPAN</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> \
        <span class="n">available_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">=</span> <span class="n">Span</span><span class="p">(</span><span class="n">span</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="o">=</span> <span class="n">available_only</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span>
            <span class="n">user_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">available_only</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_available</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ReplayMap</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="MapUser.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.MapUser.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">MapUser</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">map_id</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">span</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayCache"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayCache">[docs]</a><span class="k">class</span> <span class="nc">ReplayCache</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Contains replays represented by a circlecore database. Primarily useful</span>
<span class="sd">    to randomly sample these replays, rather than directly access them.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: string</span>
<span class="sd">        The path to the database to load replays from.</span>
<span class="sd">    num_maps: int</span>
<span class="sd">        How many (randomly chosen) maps to load replays from.</span>
<span class="sd">    limit: int</span>
<span class="sd">        How many replays to load for each map.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    :meth:`~circleguard.circleguard.Circleguard.load_info` is an expensive</span>
<span class="sd">    operation for large databases created on circlecore version 4.3.5 or</span>
<span class="sd">    earlier, as they do not have the necessary indexes.</span>
<span class="sd">    |br|</span>
<span class="sd">    For databases created in later versions, this is a nonissue and the lookup</span>
<span class="sd">    is fast.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">num_maps</span><span class="p">,</span> <span class="n">num_replays</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span> <span class="o">=</span> <span class="n">num_maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">num_replays</span> <span class="o">*</span> <span class="n">num_maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">map_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="sd">"""</span>
<span class="sd">            SELECT DISTINCT map_id</span>
<span class="sd">            FROM replays</span>
<span class="sd">            """</span>
        <span class="p">)</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>

        <span class="c1"># flatten map_ids, because it's actually a list of lists</span>
        <span class="n">map_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">map_ids</span><span class="p">]</span>
        <span class="n">chosen_maps</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choices</span><span class="p">(</span><span class="n">map_ids</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_maps</span><span class="p">)</span>

        <span class="n">subclauses</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">"map_id = </span><span class="si">{</span><span class="n">chosen_map</span><span class="si">}</span><span class="s2">"</span> <span class="k">for</span> <span class="n">chosen_map</span> <span class="ow">in</span> <span class="n">chosen_maps</span><span class="p">]</span>
        <span class="n">where_clause</span> <span class="o">=</span> <span class="s2">" OR "</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">subclauses</span><span class="p">)</span>

        <span class="c1"># TODO LIMIT clause isn't quite right here, some maps will have less</span>
        <span class="c1"># than ``num_replays`` stored</span>
        <span class="n">infos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">"""</span>
<span class="s2">            SELECT user_id, map_id, replay_data, replay_id, mods</span>
<span class="s2">            FROM replays</span>
<span class="s2">            WHERE </span><span class="si">{</span><span class="n">where_clause</span><span class="si">}</span><span class="s2"></span>
<span class="s2">            LIMIT </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="si">}</span><span class="s2"></span>
<span class="s2">            """</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">infos</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">CachedReplay</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ReplayCache.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayCache.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">path</span></div>


<div class="viewcode-block" id="ReplayDir"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDir">[docs]</a><span class="k">class</span> <span class="nc">ReplayDir</span><span class="p">(</span><span class="n">ReplayContainer</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A folder with replay files inside it.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Any files not ending in ``.osr`` are ignored.</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    Nested directories are not support (yet). Any folders encountered will be</span>
<span class="sd">    ignored.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dir_path</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">dir_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Expected path pointing to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span><span class="si">}</span><span class="s2"> to be"</span>
                <span class="s2">" a directory"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replays</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">load_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">".osr"</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">replay</span> <span class="o">=</span> <span class="n">ReplayPath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">/</span> <span class="n">path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">replay</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info_loaded</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ReplayDir.all_replays"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayDir.all_replays">[docs]</a>    <span class="k">def</span> <span class="nf">all_replays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replays</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dir_path</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">dir_path</span></div>


<div class="viewcode-block" id="Replay"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay">[docs]</a><span class="k">class</span> <span class="nc">Replay</span><span class="p">(</span><span class="n">Loadable</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A replay played by a player.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    weight: :class:`~circleguard.utils.RatelimitWeight`</span>
<span class="sd">        How much it 'costs' to load this replay from the api.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    game_version: :class:`~circleguard.game_version.GameVersion`</span>
<span class="sd">        Information about the version of osu! the replay was played on.</span>
<span class="sd">    timestamp: :class:`datetime.datetime`</span>
<span class="sd">        When the replay was played.</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The id of the map the replay was played on, or 0 if</span>
<span class="sd">        unknown or on an unsubmitted map.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The id of the player who played the replay, or 0 if unknown</span>
<span class="sd">        (if the player is restricted, for instance). Note that if the</span>
<span class="sd">        user id is known, even if the user is restricted, it should still be</span>
<span class="sd">        given instead of 0.</span>
<span class="sd">    username: str</span>
<span class="sd">        The username of the player who played the replay.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        The mods the replay was played with.</span>
<span class="sd">    replay_id: int</span>
<span class="sd">        The id of the replay, or 0 if the replay is unsubmitted.</span>
<span class="sd">    keydowns: ndarray[int]</span>
<span class="sd">        The keydowns for each frame of the replay. Keydowns are the keys pressed</span>
<span class="sd">        in that frame that were not pressed in the previous frame. See</span>
<span class="sd">        :meth:`~circleguard.loadables.Replay.keydowns` for more details.</span>
<span class="sd">    t: ndarray[int]</span>
<span class="sd">        A 1d array containing the timestamp for each frame.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    xy: ndarray[float]</span>
<span class="sd">        A 2d, two column array, containing the ``x`` and ``y`` coordinates of</span>
<span class="sd">        each frame in the first and second column respectively.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    k: ndarray[int]</span>
<span class="sd">        A 1d array containing the keys pressed for each frame.</span>
<span class="sd">        |br|</span>
<span class="sd">        This is only nonnull after the replay has been loaded.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span>

        <span class="c1"># These attributes might or might not be set once the replay loads.</span>
        <span class="c1"># Ideally, a replay would provide all of these attributes, but there are</span>
        <span class="c1"># some cases when only a subset is available. &lt;br&gt;</span>
        <span class="c1"># If only some of these attributes are set after the replay is loaded,</span>
        <span class="c1"># some ``Circleguard`` methods may reject this replay, as it does not</span>
        <span class="c1"># contain the information necessary to do whatever the method needs to.</span>
        <span class="c1"># &lt;br&gt;</span>
        <span class="c1"># For instance, if the replay provides ``replay_data`` but not ``mods``,</span>
        <span class="c1"># ``Circleguard#similarity`` will reject it, as we will not know whether</span>
        <span class="c1"># whether ``Mod.HR`` was enabled on the replay, and thus whether to flip</span>
        <span class="c1"># the replay before comparing it to another one.</span>

        <span class="c1"># replays have no information about their game version by default.</span>
        <span class="c1"># Subclasses might set this if they have more information to provide</span>
        <span class="c1"># about their version, whether on instantiation or after being loaded.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">NoGameVersion</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span>    <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># declared as a property with a getter and setter so we can set</span>
        <span class="c1"># map_info's map_id attribute automatically</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_id</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># replays have no information about their map by default.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span>     <span class="o">=</span> <span class="n">MapInfo</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span>     <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span>      <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span>         <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span>    <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span>  <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># These attributes remain ``None``` when replay is unloaded or loaded</span>
        <span class="c1"># but with no data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span>            <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span>           <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span>            <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span>    <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Replay.has_data"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay.has_data">[docs]</a>    <span class="k">def</span> <span class="nf">has_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Whether this replay has any replay data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Whether this replay has any replay data.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If this replay is unloaded, it is guaranteed to not have any replay</span>
<span class="sd">        data. But if the replay is loaded, it is not guaranteed to have any</span>
<span class="sd">        replay data. Some replays do not have any replay data available from</span>
<span class="sd">        the api, even after being loaded.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Replay.beatmap"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.Replay.beatmap">[docs]</a>    <span class="k">def</span> <span class="nf">beatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">library</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        The beatmap this replay was played on.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        library: :class:`slider.library.Library`</span>
<span class="sd">            The library used by the calling</span>
<span class="sd">            :class:`~circleguard.circleguard.Circleguard` instance. Beatmaps</span>
<span class="sd">            which have already been downloaded and are cached in this library</span>
<span class="sd">            may be returned here instead of redownloading them.</span>
<span class="sd">            |br|</span>
<span class="sd">            Beatmaps which we download or create in this method, but were not</span>
<span class="sd">            previously stored in the library, may also be stored into the</span>
<span class="sd">            library for future use as a result of calling this method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`slider.beatmap.Beatmap`</span>
<span class="sd">            The beatmap this replay was played on.</span>
<span class="sd">        None</span>
<span class="sd">            If we do not know what beatmap this replay was played on.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">available</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># prefer loading from disk, it's cheaper than potentially downloading</span>
        <span class="c1"># the beatmap from osu! servers</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">path</span><span class="p">:</span>
            <span class="c1"># by default we don't save beatmaps that are already saved on disk.</span>
            <span class="c1"># Subclasses should override `#beatmap` and pass `copy=True` here</span>
            <span class="c1"># in their overridden method if they want to copy the beatmap to the</span>
            <span class="c1"># library's directory.</span>
            <span class="k">return</span> <span class="n">library</span><span class="o">.</span><span class="n">beatmap_from_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">map_id</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">library</span><span class="o">.</span><span class="n">lookup_by_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">download</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_process_replay_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_data</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Preprocesses the replay data (turns it into numpy arrays) for fast</span>
<span class="sd">        manipulation when investigating.</span>

<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">        replay_data: list[:class:`~osrparse.Replay.ReplayEvent`]</span>
<span class="sd">            A list of :class:`~osrparse.Replay.ReplayEvent` objects,</span>
<span class="sd">            representing the actual data of the replay. If the replay could not</span>
<span class="sd">            be loaded, this should be ``None``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method must be called before a replay can be considered loaded</span>
<span class="sd">        (ie before you set ``loaded`` to ``True``).</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span>
        <span class="c1"># replay wasn't available, can't preprocess the data</span>
        <span class="k">if</span> <span class="n">replay_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># In rare cases (I'm not quite sure how to reproduce), a replay's replay</span>
        <span class="c1"># data can be empty. We check this here to throw a clearer error</span>
        <span class="c1"># message than the IndexError we will get shortly after with</span>
        <span class="c1"># ``replay_data[0]``.</span>
        <span class="c1">#</span>
        <span class="c1"># Note that there's an important distinction between ``replay_data``</span>
        <span class="c1"># being ``None`` and being the empty list ``[]`` - the former means the</span>
        <span class="c1"># api (or osr, or some other source) had no replay data for this replay,</span>
        <span class="c1"># and the latter means it *had* replay data, it was just empty replay</span>
        <span class="c1"># data.</span>
        <span class="c1">#</span>
        <span class="c1"># It might be okay to just return as with the ``replay_data is None``</span>
        <span class="c1"># case, but I'm erring on the side of caution and throwing for now.</span>
        <span class="c1">#</span>
        <span class="c1"># See https://github.com/circleguard/circleguard/issues/133 for examples</span>
        <span class="c1"># of replays exhibiting this behavior.</span>
        <span class="k">if</span> <span class="n">replay_data</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"This replay's replay data was empty. This should "</span>
                <span class="s2">"not happen and is indicative of a misbehaved replay."</span><span class="p">)</span>

        <span class="c1"># remove invalid zero time frame at beginning of replay</span>
        <span class="c1"># https://github.com/ppy/osu/blob/1587d4b26fbad691242544a62dbf017a78705</span>
        <span class="c1"># ae3/osu.Game/Scoring/Legacy/LegacyScoreDecoder.cs#L242-L245</span>
        <span class="k">if</span> <span class="n">replay_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">time_since_previous_action</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># t, x, y, k</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="c1">## TODO try to use a peekable iterator to use an iter for above as well</span>
        <span class="c1"># use an iter an an optimization so we don't recreate the list when</span>
        <span class="c1"># taking (and removing) the first element</span>
        <span class="n">replay_data</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="c1"># The following comments in this method are guesswork, but seems to</span>
        <span class="c1"># accurately describe replays. This references the "first" frame</span>
        <span class="c1"># assuming that we have already removed the truly first zero time</span>
        <span class="c1"># frame, if it is present. So technically the "first" frame below may</span>
        <span class="c1"># be the second frame.</span>
        <span class="c1"># There are two possibilities for replays:</span>
        <span class="c1"># * for replays with a skip in the beginning, the first frame time is</span>
        <span class="c1">#   the skip duration. The next frame after that will have a negative</span>
        <span class="c1">#   time, to account for the replay data before the skip.</span>
        <span class="c1"># * for replays without a skip in the beginning, the first frame time</span>
        <span class="c1">#   is -1.</span>
        <span class="c1"># Since in the first case the first frame time is a large positive,</span>
        <span class="c1"># this would make ``highest_running_t`` large and cause all replay data</span>
        <span class="c1"># before the skip to be ignored. To solve this, we initialize</span>
        <span class="c1"># ``running_t`` to the first frame's time.</span>
        <span class="n">running_t</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span><span class="o">.</span><span class="n">time_since_previous_action</span>
        <span class="c1"># We consider negative time frames in the middle of replays to be</span>
        <span class="c1"># valid, with a caveat. Their negative time is counted toward</span>
        <span class="c1"># ``running_t`` (that is, decreases ``running_t``), but any frames</span>
        <span class="c1"># after it are ignored, until the total time passed of ignored frames</span>
        <span class="c1"># is greater than or equal to the negative frame.</span>
        <span class="c1"># There's one more catch - the frame that brings us *out* of this</span>
        <span class="c1"># "negative time" section where we're ignoring frames will cause a</span>
        <span class="c1"># special frame to be inserted, which has the same time as the frame</span>
        <span class="c1"># that brought us *into* the negative time section, and specially</span>
        <span class="c1"># calculated x and y positions. Details below.</span>
        <span class="c1"># I do not know why stable treats negative time frames in this way.</span>
        <span class="c1"># It is not what lazer does, as far as I can tell. But it is the only</span>
        <span class="c1"># reasonable explanation for stable behavior. This solution may not,</span>
        <span class="c1"># however, be the canonical solution.</span>
        <span class="n">highest_running_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NINF</span>
        <span class="c1"># The last positive frame we encountered before entering a negative</span>
        <span class="c1"># section.</span>
        <span class="n">last_positive_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># the running time when we encountered ``last_positive_frame``. We need</span>
        <span class="c1"># to save this as we do not store this information in each individual</span>
        <span class="c1"># frame.</span>
        <span class="n">last_positive_frame_cum_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">previous_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">replay_data</span><span class="p">:</span>
            <span class="c1"># check if we were in a negative section of the play at the</span>
            <span class="c1"># previous frame (f0) before applying the current frame (f1), so we</span>
            <span class="c1"># can apply special logic if f1 is the frame that gets us out of</span>
            <span class="c1"># the negative section.</span>
            <span class="n">was_in_negative_section</span> <span class="o">=</span> <span class="n">running_t</span> <span class="o">&lt;</span> <span class="n">highest_running_t</span>

            <span class="n">e_t</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">time_since_previous_action</span>
            <span class="n">running_t</span> <span class="o">+=</span> <span class="n">e_t</span>
            <span class="n">highest_running_t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">highest_running_t</span><span class="p">,</span> <span class="n">running_t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">running_t</span> <span class="o">&lt;</span> <span class="n">highest_running_t</span><span class="p">:</span>
                <span class="c1"># if we weren't in a negative section in f0, f1 is the first</span>
                <span class="c1"># frame to bring us into one, so f0 is the last positive frame.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">was_in_negative_section</span><span class="p">:</span>
                    <span class="n">last_positive_frame</span> <span class="o">=</span> <span class="n">previous_frame</span>
                    <span class="c1"># we want to set it to the cumulative time before f1</span>
                    <span class="c1"># was processed, so subtract out the current e_t</span>
                    <span class="n">last_positive_frame_cum_time</span> <span class="o">=</span> <span class="n">running_t</span> <span class="o">-</span> <span class="n">e_t</span>
                <span class="n">previous_frame</span> <span class="o">=</span> <span class="n">e</span>
                <span class="k">continue</span>

            <span class="c1"># if we get here, f1 brought us out of the negative section. In</span>
            <span class="c1"># this case, osu! actually inserts a new frame, with:</span>
            <span class="c1"># * t = the cumulative time at the last positive frame (yes, this</span>
            <span class="c1">#   means there are two frames at the same time in the replay</span>
            <span class="c1">#   playback).</span>
            <span class="c1"># * x, y = a weighted average between the positions of f0 and f1,</span>
            <span class="c1">#   weighted by how close the last positive frame's time is to each</span>
            <span class="c1">#   of the two frames' times.</span>
            <span class="c1"># * k = the keypresses of the last positive frame.</span>
            <span class="k">if</span> <span class="n">was_in_negative_section</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">)</span>

                <span class="c1"># this is [running_t at f0, running_t at f1], to interpolate</span>
                <span class="c1"># the last positive frame's time between.</span>
                <span class="n">xp</span> <span class="o">=</span> <span class="p">[</span><span class="n">running_t</span> <span class="o">-</span> <span class="n">e_t</span><span class="p">,</span> <span class="n">running_t</span><span class="p">]</span>

                <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="n">previous_frame</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="n">fp</span> <span class="o">=</span> <span class="p">[</span><span class="n">previous_frame</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">y</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">last_positive_frame_cum_time</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

                <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_positive_frame</span><span class="o">.</span><span class="n">keys_pressed</span><span class="p">)</span>

            <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">running_t</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">keys_pressed</span><span class="p">)</span>
            <span class="n">previous_frame</span> <span class="o">=</span> <span class="n">e</span>

        <span class="n">block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">block</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">block</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># sort our data by t. Stable so we don't reorder frames with equal</span>
        <span class="c1"># times</span>
        <span class="n">t_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">"stable"</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>
        <span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">t_sort</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">map_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_id</span>

    <span class="nd">@map_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">map_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_info</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">keydowns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        A list of the keys pressed for each frame that were not pressed in the</span>
<span class="sd">        previous frame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        If the first frame (``f1``) has keys ``K1`` and ``f2`` has keys</span>
<span class="sd">        ``K1 + K2``, then ``keydowns[1]`` is ``K2``.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># can't do `if not self._keydowns` because the truth value of an</span>
        <span class="c1"># ndarray is ambiguous</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keypresses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">&amp;</span> <span class="n">KEY_MASK</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span> <span class="o">=</span> <span class="n">keypresses</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">keypresses</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keydowns</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"Replay(timestamp=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="si">}</span><span class="s2">,map_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">,"</span>
            <span class="sa">f</span><span class="s2">"user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,"</span>
            <span class="sa">f</span><span class="s2">"replay_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="si">}</span><span class="s2">,weight=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2">,"</span>
            <span class="sa">f</span><span class="s2">"loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">,username=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"Replay by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">"</span></div>


<div class="viewcode-block" id="ReplayMap"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayMap">[docs]</a><span class="k">class</span> <span class="nc">ReplayMap</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A :class:`~.Replay` that was submitted to online servers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    map_id: int</span>
<span class="sd">        The id of the map the replay was played on.</span>
<span class="sd">    user_id: int</span>
<span class="sd">        The id of the player who played the replay.</span>
<span class="sd">    mods: :class:`~circleguard.mod.ModCombination`</span>
<span class="sd">        The mods the replay was played with. If ``None``, the</span>
<span class="sd">        highest scoring replay of ``user_id`` on ``map_id`` will be loaded,</span>
<span class="sd">        regardless of mod combination. Otherwise, the replay with ``mods``</span>
<span class="sd">        will be loaded.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is unloaded:</span>

<span class="sd">    * map_id</span>
<span class="sd">    * user_id</span>
<span class="sd">    * mods (if passed)</span>

<span class="sd">    In addition to the above, the following replay-related attributes are</span>
<span class="sd">    available (not ``None``) when this replay is loaded:</span>

<span class="sd">    * timestamp</span>
<span class="sd">    * username</span>
<span class="sd">    * mods</span>
<span class="sd">    * replay_id</span>
<span class="sd">    * replay_data</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_id</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">mods</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">HEAVY</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">".ReplayMap"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">timestamp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">map_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">user_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">username</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span>

<div class="viewcode-block" id="ReplayMap.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayMap.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loads the data for this replay from the api.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~.loader.Loader`</span>
<span class="sd">            The :class:`~.loader.Loader` to load this replay with.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache this replay after loading it. This only has an</span>
<span class="sd">            effect if ``self.cache`` is unset (``None``).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``replay.loaded`` is ``True``, this method has no effect.</span>
<span class="sd">        ``replay.loaded`` is set to ``True`` after this method is finished.</span>
<span class="sd">        """</span>
        <span class="c1"># only listen to the parent's cache if ours is not set. Lower takes</span>
        <span class="c1"># precedence</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Loading </span><span class="si">%r</span><span class="s2">"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2"> already loaded, not loading"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="n">user_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span>
                <span class="n">mods</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="c1"># estimate version with timestamp, this is only accurate if the user</span>
        <span class="c1"># keeps their game up to date</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">GameVersion</span><span class="o">.</span><span class="n">from_datetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span>
            <span class="n">concrete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">username</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">mods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">replay_id</span>

        <span class="n">replay_data</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_data</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">"Finished loading </span><span class="si">%s</span><span class="s2">"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Whether the two replay maps are equal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This does not take into account the</span>
<span class="sd">        ``cache`` attribute, because equality here means "do they represent the</span>
<span class="sd">        same replays".</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayMap</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">()</span> <span class="ow">and</span> <span class="n">loadable</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">map_id</span> <span class="ow">and</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">user_id</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">mods</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"ReplayMap(timestamp=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span><span class="si">}</span><span class="s2">,map_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">"</span>
            <span class="sa">f</span><span class="s2">",user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,cache=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="si">}</span><span class="s2">,"</span>
            <span class="sa">f</span><span class="s2">"replay_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="si">}</span><span class="s2">,loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">,"</span>
            <span class="sa">f</span><span class="s2">"username=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"ReplayMap(map_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">,user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,cache=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="si">}</span><span class="s2">,loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="s1">'Loaded'</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="k">else</span> <span class="s1">'Unloaded'</span><span class="si">}</span><span class="s2"> ReplayMap by "</span>
            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayPath"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayPath">[docs]</a><span class="k">class</span> <span class="nc">ReplayPath</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A :class:`~.Replay` saved locally in a ``.osr`` file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path: str or :class:`os.PathLike`</span>
<span class="sd">        The path to the replay file.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that currently</span>
<span class="sd">        we do not cache :class:`~.ReplayPath` regardless of this parameter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ReplayPaths have no replay-related attributes available (not ``None``) when</span>
<span class="sd">    they are unloaded.</span>

<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is loaded:</span>

<span class="sd">    * timestamp</span>
<span class="sd">    * map_id</span>
<span class="sd">    * username</span>
<span class="sd">    * user_id</span>
<span class="sd">    * mods</span>
<span class="sd">    * replay_id</span>
<span class="sd">    * beatmap_hash</span>
<span class="sd">    * replay_data</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">LIGHT</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">".ReplayPath"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">absolute</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ReplayPath.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayPath.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loads the data for this replay from the osr file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~.loader.Loader`</span>
<span class="sd">            The :class:`~.loader.Loader` to load this replay with.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache this replay after loading it. This only has an</span>
<span class="sd">            effect if ``self.cache`` is unset (``None``). Note that currently</span>
<span class="sd">            we do not cache :class:`~.ReplayPath` regardless of this parameter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``replay.loaded`` is ``True``, this method has no effect.</span>
<span class="sd">        ``replay.loaded`` is set to ``True`` after this method is finished.</span>
<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Loading ReplayPath </span><span class="si">%r</span><span class="s2">"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2"> already loaded, not loading"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">loaded</span> <span class="o">=</span> <span class="n">osrparse</span><span class="o">.</span><span class="n">parse_replay_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">GameVersion</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">game_version</span><span class="p">,</span> <span class="n">concrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">map_id</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">player_name</span>
        <span class="c1"># our `user_id` attribute is lazy loaded, so we need to retain the</span>
        <span class="c1"># `Loader#user_id` function to use later to load it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">mod_combination</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">replay_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">beatmap_hash</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">play_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">"Finished loading </span><span class="si">%s</span><span class="s2">"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># we don't have a user_id_func if we're not loaded, so early return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span>

    <span class="nd">@user_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="n">user_id</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Whether these replay paths are equal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If one or both replay paths don't have replay data, this checks path</span>
<span class="sd">        equality. If both replay paths have replay data, this checks the</span>
<span class="sd">        equality of their replay data.</span>
<span class="sd">        |br|</span>
<span class="sd">        The reason we don't check path after both are loaded is to avoid</span>
<span class="sd">        true in situations like this:</span>

<span class="sd">        ```</span>
<span class="sd">        r1 = ReplayPath("./1.osr")</span>
<span class="sd">        cg.load(r1)</span>
<span class="sd">        # change the file located at ./1.osr to another osr file</span>
<span class="sd">        r2 = ReplayPath("./1.osr")</span>
<span class="sd">        cg.load(r2)</span>
<span class="sd">        r1 == r2 # should be False, as they have differing replay data</span>
<span class="sd">        ```</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayPath</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_data</span><span class="p">()</span> <span class="ow">and</span> <span class="n">loadable</span><span class="o">.</span><span class="n">has_data</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">path</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"ReplayPath(path=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">,map_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"replay_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="si">}</span><span class="s2">,weight=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">,username=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"ReplayPath(path=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">,weight=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"Loaded ReplayPath by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2"> at"</span>
                <span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"Unloaded ReplayPath at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">"</span></div>


<div class="viewcode-block" id="ReplayString"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayString">[docs]</a><span class="k">class</span> <span class="nc">ReplayString</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A :class:`~.Replay` saved locally in a ``.osr`` file, when the file has</span>
<span class="sd">    already been read as a string.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    replay_data_str: str</span>
<span class="sd">        The contents of the replay file as a string.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that currently</span>
<span class="sd">        we do not cache :class:`~.ReplayString` regardless of this parameter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ReplayPaths have no replay-related attributes available (not ``None``) when</span>
<span class="sd">    they are unloaded.</span>

<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is loaded:</span>

<span class="sd">    * timestamp</span>
<span class="sd">    * map_id</span>
<span class="sd">    * username</span>
<span class="sd">    * user_id</span>
<span class="sd">    * mods</span>
<span class="sd">    * replay_id</span>
<span class="sd">    * beatmap_hash</span>
<span class="sd">    * replay_data</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; replay_data = open("replay.osr", "rb").read()</span>
<span class="sd">    &gt;&gt;&gt; r = ReplayString(replay_data)</span>
<span class="sd">    &gt;&gt;&gt; cg.load(r)</span>
<span class="sd">    &gt;&gt;&gt; print(cg.ur(r))</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_data_str</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">LIGHT</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">".ReplayString"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span> <span class="o">=</span> <span class="n">replay_data_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ReplayString.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayString.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Loads the data for this replay from the string replay data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loader: :class:`~.loader.Loader`</span>
<span class="sd">            The :class:`~.loader.Loader` to load this replay with.</span>
<span class="sd">        cache: bool</span>
<span class="sd">            Whether to cache this replay after loading it. This only has an</span>
<span class="sd">            effect if ``self.cache`` is unset (``None``). Note that currently</span>
<span class="sd">            we do not cache :class:`~.ReplayString` regardless of this</span>
<span class="sd">            parameter.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``replay.loaded`` is ``True``, this method has no effect.</span>
<span class="sd">        ``replay.loaded`` is set to ``True`` after this method is finished.</span>
<span class="sd">        """</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"Loading ReplayString </span><span class="si">%r</span><span class="s2">"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">"</span><span class="si">%s</span><span class="s2"> already loaded, not loading"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">loaded</span> <span class="o">=</span> <span class="n">osrparse</span><span class="o">.</span><span class="n">parse_replay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">,</span> <span class="n">pure_lzma</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_version</span> <span class="o">=</span> <span class="n">GameVersion</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">game_version</span><span class="p">,</span> <span class="n">concrete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">map_id</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">beatmap_hash</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">player_name</span>
        <span class="c1"># our `user_id` attribute is lazy loaded, so we need to retain the</span>
        <span class="c1"># `Loader#user_id` function to use later to load it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">mod_combination</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">replay_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beatmap_hash</span> <span class="o">=</span> <span class="n">loaded</span><span class="o">.</span><span class="n">beatmap_hash</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">loaded</span><span class="o">.</span><span class="n">play_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">TRACE</span><span class="p">,</span> <span class="s2">"Finished loading </span><span class="si">%s</span><span class="s2">"</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># we don't have a user_id_func if we're not loaded, so early return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span>

    <span class="nd">@user_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">user_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_id</span> <span class="o">=</span> <span class="n">user_id</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loadable</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loadable</span><span class="p">,</span> <span class="n">ReplayString</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span> <span class="o">==</span> <span class="n">loadable</span><span class="o">.</span><span class="n">replay_data_str</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"ReplayString(len(replay_data_str)="</span>
                <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span><span class="si">}</span><span class="s2">,map_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"user_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s2">,mods=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mods</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"replay_id=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="si">}</span><span class="s2">,weight=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="si">}</span><span class="s2">,"</span>
                <span class="sa">f</span><span class="s2">"loaded=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="si">}</span><span class="s2">,username=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">"ReplayString(len(replay_data_str)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">"Loaded ReplayString by </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">username</span><span class="si">}</span><span class="s2"> on </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">map_id</span><span class="si">}</span><span class="s2">"</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">"Unloaded ReplayString with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data_str</span><span class="p">)</span><span class="si">}</span><span class="s2"> "</span>
            <span class="s2">"chars of data"</span><span class="p">)</span></div>


<div class="viewcode-block" id="ReplayID"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayID">[docs]</a><span class="k">class</span> <span class="nc">ReplayID</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    A :class:`~.Replay` that was submitted online and is represented by a unique</span>
<span class="sd">    replay id.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    replay_id: int</span>
<span class="sd">        The id of the replay.</span>
<span class="sd">    cache: bool</span>
<span class="sd">        Whether to cache this replay once it is loaded. Note that we currently</span>
<span class="sd">        do not cache ReplayIDs.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The following replay-related attributes are available (not ``None``) when</span>
<span class="sd">    this replay is unloaded:</span>

<span class="sd">    * replay_id</span>

<span class="sd">    In addition to the above, the following replay-related attributes are</span>
<span class="sd">    available (not ``None``) when this replay is loaded:</span>

<span class="sd">    * replay_data</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">replay_id</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">HEAVY</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">replay_id</span>

<div class="viewcode-block" id="ReplayID.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.ReplayID.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="c1"># TODO file github issue about loading info from replay id, right now we</span>
        <span class="c1"># can literally only load the replay data which isn't that useful</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="n">cache</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span>
        <span class="n">replay_data</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">replay_data_from_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">,</span> <span class="n">cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">replay_id</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">)</span></div>


<div class="viewcode-block" id="CachedReplay"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.CachedReplay">[docs]</a><span class="k">class</span> <span class="nc">CachedReplay</span><span class="p">(</span><span class="n">Replay</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    This class is intended to be instantiated from</span>
<span class="sd">    :func:`~.ReplayCache.load_info` and should not be instantiated manually.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="p">,</span> <span class="n">map_id</span><span class="p">,</span> <span class="n">mods</span><span class="p">,</span> <span class="n">replay_data</span><span class="p">,</span> <span class="n">replay_id</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">RatelimitWeight</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_id</span> <span class="o">=</span> <span class="n">map_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mods</span> <span class="o">=</span> <span class="n">Mod</span><span class="p">(</span><span class="n">mods</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span> <span class="o">=</span> <span class="n">replay_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">=</span> <span class="n">replay_id</span>

<div class="viewcode-block" id="CachedReplay.load"><a class="viewcode-back" href="../../appendix.html#circleguard.loadables.CachedReplay.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loader</span><span class="p">,</span> <span class="n">cache</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">decompressed</span> <span class="o">=</span> <span class="n">wtc</span><span class="o">.</span><span class="n">decompress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_data</span><span class="p">)</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="n">osrparse</span><span class="o">.</span><span class="n">parse_replay</span><span class="p">(</span><span class="n">decompressed</span><span class="p">,</span> <span class="n">pure_lzma</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_replay_data</span><span class="p">(</span><span class="n">parsed</span><span class="o">.</span><span class="n">play_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loaded</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">replay_id</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">replay_id</span><span class="p">)</span></div>
</pre></div>
      </article>
      <footer>
        
        <div class="related-pages">
          
          
        </div>

        <div class="related-information">
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </main>
</div>
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/scripts/main.js?digest=e931d09b2a40c1bb82b542effe772014573baf67"></script></body>
</html>